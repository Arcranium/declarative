"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/arrays/index.ts
var arrays_exports = {};
__export(arrays_exports, {
  arrayInsert: () => arrayInsert,
  arrayInsertMutable: () => arrayInsertMutable,
  arrayOfLength: () => arrayOfLength,
  arrayRange: () => arrayRange,
  arrayRemove: () => arrayRemove,
  arrayRemoveMutable: () => arrayRemoveMutable,
  arraySample: () => arraySample,
  arrayShuffle: () => arrayShuffle,
  arrayUnique: () => arrayUnique,
  arraysDifference: () => arraysDifference,
  arraysIntersection: () => arraysIntersection,
  arraysUnion: () => arraysUnion,
  asyncArray: () => asyncArray,
  toArray: () => toArray
});
module.exports = __toCommonJS(arrays_exports);

// src/arrays/array-insert/array-insert.ts
var arrayInsertMutable = (arr, index, ...items) => {
  arr.splice(index, 0, ...items);
  return arr;
};
var arrayInsert = (arr, index, ...items) => arrayInsertMutable([...arr], index, ...items);

// src/guards/is-array/is-array.ts
var isArray = (value) => Array.isArray(value);

// src/guards/is-integer/is-integer.ts
var isInteger = (value) => Number.isInteger(value);

// src/arrays/array-of-length/array-of-length.ts
var arrayOfLength = (length, mapFunction) => {
  const neededLength = isInteger(length) && length > 0 ? length : 0;
  const arr = new Array(neededLength).fill(void 0);
  return mapFunction ? arr.map((_, index) => mapFunction(index)) : arr;
};

// src/arrays/array-range/array-range.ts
var arrayRange = (from, to) => {
  if (to === void 0) {
    if (from < 0) {
      to = 0;
    } else {
      to = from;
      from = 0;
    }
  }
  return arrayOfLength(Math.abs(to - from) + 1, (index) => index).map((i) => (from > to ? -i : i) + from);
};

// src/arrays/array-remove/array-remove.ts
var arrayRemoveMutable = (arr, value, onlyFirst = false) => {
  while (true) {
    const occurrence = arr.indexOf(value);
    if (occurrence === -1)
      return arr;
    arr.splice(occurrence, 1);
    if (onlyFirst)
      return arr;
  }
};
var arrayRemove = (arr, value, onlyFirst = false) => arrayRemoveMutable([...arr], value, onlyFirst);

// src/numbers/random-integer/random-integer.ts
var randomInteger = (min = 1, max = Number.MAX_SAFE_INTEGER) => Math.floor(Math.random() * (max - min + 1)) + min;

// src/arrays/array-shuffle/array-shuffle.ts
var arrayShuffle = (array) => {
  const copy = [...array];
  for (let i = copy.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [copy[i], copy[j]] = [copy[j], copy[i]];
  }
  return copy;
};

// src/arrays/array-sample/array-sample.ts
var arraySample = (array, size = 1, oversize = false) => {
  if (!array?.length || !isInteger(size) || size < 1)
    return void 0;
  if (size === 1) {
    return array[randomInteger(0, array.length - 1)];
  }
  !oversize && (size = Math.min(array.length, size));
  const result = [];
  while (result.length < size) {
    const neededCount = size - result.length;
    const iterationIndexes = arrayOfLength(array.length, (index) => index);
    if (neededCount > array.length) {
      result.push(...iterationIndexes.map((i) => array[i]));
    } else {
      result.push(...arrayShuffle(iterationIndexes).slice(0, neededCount).map((i) => array[i]));
    }
  }
  return result;
};

// src/arrays/array-unique/array-unique.ts
var arrayUnique = (array) => [...new Set(array)];

// src/arrays/arrays-intersection/arrays-intersection.ts
var arraysIntersection = (...arrays) => arrays.reduce((acc, array) => acc.filter((i) => array.includes(i)));

// src/arrays/arrays-union/arrays-union.ts
var arraysUnion = (...arrays) => [...new Set(arrays.flat())];

// src/arrays/arrays-difference/arrays-difference.ts
var arraysDifference = (...arrays) => {
  const intersections = arraysIntersection(...arrays);
  return arraysUnion(...arrays.map((array) => array.filter((i) => !intersections.includes(i))));
};

// src/arrays/async-array/async-array.utils.ts
var resolve = async (collectionOrPromise) => {
  if (isArray(collectionOrPromise))
    return Promise.all(collectionOrPromise);
  return Promise.all([collectionOrPromise]);
};
var series = (reducer, initial, order = "left-to-right") => {
  const method = order === "left-to-right" ? "reduce" : "reduceRight";
  return (iterable) => {
    return iterable[method]((accumulator, value, index) => {
      return accumulator.then((results) => reducer(results, value, index, iterable));
    }, Promise.resolve(initial));
  };
};

// src/arrays/async-array/async-array.ts
function forEach(callback) {
  return resolve(this).then(
    series((results, value, index, arr) => callback(value, index, arr), void 0)
  );
}
function reduce(reducer, initial) {
  return resolve(this).then(
    series(reducer, initial, "left-to-right")
  );
}
function reduceRight(reducer, initial) {
  return resolve(this).then(
    series(reducer, initial, "right-to-left")
  );
}
function map(mapper) {
  return resolve(this).then(
    (values) => Promise.all(
      values.map((value, index, arr) => mapper(value, index, arr))
    )
  );
}
var asyncArray = (arr) => {
  return {
    forEach: forEach.bind(arr),
    reduce: reduce.bind(arr),
    reduceRight: reduceRight.bind(arr),
    map: map.bind(arr)
  };
};

// src/arrays/to-array/to-array.ts
var toArray = (value) => [value].flat();
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  arrayInsert,
  arrayInsertMutable,
  arrayOfLength,
  arrayRange,
  arrayRemove,
  arrayRemoveMutable,
  arraySample,
  arrayShuffle,
  arrayUnique,
  arraysDifference,
  arraysIntersection,
  arraysUnion,
  asyncArray,
  toArray
});
